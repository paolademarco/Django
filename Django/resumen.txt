Para construir app webs, framework
Se recomienda usar pipenv para encapsular la version de Django al proyecto actual
se descarga en la terminal luego de generar un ambiente virtual
django-admin startproject "nombre del proyecto" . (el punto al final es FUNDAMENTAL)
--init-- es para poder transformar la carpeta en un paquete
settings es un archivo para poner configuraciones referentes al proyecto
URLs es para configurar las rutas de nuestro proyecto
http://127.0.0.1:8000/ 8000 es el puerto y lo anterior es la ruta donde se va a desplegar
Podemos tener varias aplicaciones dentro de un mismo proyecto
dentro del proyecto podemos tener:
    app 1
    app2
    admin  (reutilizable entre apps)
    frontend (reutilizable entre apps)
    Checkout
son apps peque;as faciles de mantener

generamos la app desde la terminal. python startapp "nombre de la app"
nos genera una carpeta con el nombre de la appgenera una subcarpeta migrations que se encarga de mantener todos
los cambios que se van a realizar a una base de datos.

models va a hacer clases de referencia a tablas en las bases de datos, estaremos trabajando 
asi directamente con Python y no con SQL a no ser que queramos utilizarlo

test, nos permite poder escribir nuestros test automatizados

views:
el usuario genera una http request al servidor
el servidor devuelve una http response que puede ser definida en Django
ambos son objetos

instalar "productos" solo generamos hasta ahora la estructura de archivos

Se configuran las URLs:
primero la padre /productos
luego se configuran las rutas hijas
pueden ser /detalle o /id de producto estructura

luego seran las views:
le indicamos que es lo que tiene que ejecutar la ruta
oculto estara /productos/index
le indicamos index para ejecutar
index(request)

si en app.py muestra error, hay que seleccionar el interprete correcto donde muestra abajo la version de
python que se esta usando, se selecciona la correspondiente a la carpeta donde esta la app

En settings.py, agregamos a los Programas instalados 'productos.apps.ProductosConfig' lo ultimo es la clase
que nos aparece en apps.py, para poder vincularla

En URLs, en los paths, se agrega con la misma convencion el path('productos/', )
al inicio le decimos a Django que import path, include
path('productos/', include('productos.urls'))
creamos el archivo urls.py en la carpeta de productos y utilizamos la convencion exigida 
para referenciar el path

en urls
from django.urls import path
from . import views  # debe tener el punto para dirigir a ese archivo

urlpatterns = [path("", views.index, name="index")]

Dara error asi que vamos a views.py a crear el archivo
from django.http import HttpResponse
from django.shortcuts import render


# Create your views here.
def index(request):
    return HttpResponse("Hola Mundo!")  # en quick fix elegir add "from django"

"views" nos devolvera lo que se ve en el explorador

models.py
determinamos las clases a incluir
ORM
Object Relational Mapping
son consultas a SQL que genera Python directamente
Las clases en Python pasaran por un ORM y ese se encargara de guardarlas en las bases de datos

En las bases de datos, los datos tienen nombres similares a programacion
CharField es una cadena de texto limitada
se utiliza habitualmente un length de 255 caracteres
se ven los tipos de field a utilizar
evitar textfield y autofield
ForeignKey es una clase foranea, cuando referenciamos a otra clase en SQL
utilizando un id unico, ocupa menos espacio que nombre con descripcion

UNA VEZ DETERMINADOS LOS MODELOS, ACTUALIZAMOS LA BASE DE DATOS CON LAS MIGRACIONES

python manage.py makemigrations #en el env en terminal
Migrations for 'productos':
  productos\migrations\0001_initial.py
    - Create model Categoria
    - Create model Producto

en setting DEBE estar
  "productos.apps.ProductosConfig"

Se creo automaticamente una carpeta migrations
en 0001_initial.py estan las clases a completar
crea dentro de la clase los ID, necesarios para las bases de datos
Ese codigo no se toca, es automatico de Django, si deberemos generar las entradas en nuestros MODELOS
JAMAS SE DEBE ELIMINAR ESTE archivo ni los que se generen en esa carpeta

COMANDOS PARA MIGRAR
python manage.py makemigrations
python manage.py migrate  #para ejecutar las MIGRACIONES

Se debe crear usuario y contrasenia de admin
 python manage.py createsuperuser
usamos python manage.py runserver para ver en el explorador

Hay que configurar los modelos creados
en el archivo de admin.py
from .models import Categoria, Producto
admin.site.register(Categoria)
admin.site.register(Producto)

corremos python manage.py runserver
y vamos al explorador y ya manejamos desde alli

PERSONALIZANDO EL ADMINISTRADOR
Definir el "Categoria object" que devuelve en el explorador, se hace en modelos
en admin.py generamos una nueva clase y como argumento se lo pasamos a register

class CategoriaAdmin(admin.ModelAdmin):
    list_display = ("id", "nombre")


# Register your models here.
admin.site.register(Categoria, CategoriaAdmin)
admin.site.register(Producto)

debemos asignar __str__ tambien al modelo de producto para que cargue el nombre
Cuando generamos una clase en el admin, debemos pasarla como segundo argumento 
en el admin.site.register

Dentro de models podemos elegir que info ocultar en la web, como la fecha de creado
exclude = ("creado_en",)
debemos agregar la , para que python lea la tupla

INTERACTUANDO CON LA BASE DE DATOS
Modelos: 
  _ atributos
  _ Metodos #nos permite interactuar con bbdd sin conocer el lenguaje, sirve para consultas
    de datos en las bbdd, para interacciones mas complejas, sera a traves de SQL
  
Se hace dentro de views.py
def index(request):
    productos = Producto.objects.all()
    productos = Producto.objects.filter(puntaje__gte=3)
    great than or equal o lte less than or equal, o gt great than
    usamos el atributo a buscar y nos devuelve una lista, es un objeto que se comporta como lista
    podemos usar .get para un especifico

Para generar el index.html con la plantilla de datos a incuir, se hace dentro de 
una carpeta que se llamara TEMPLATES por convencion, Django ira a buscar alli las plantillas

usando emmet
table.table>thead>tr>th*4
esto nos crea automaticamente una table con un head, y la row con *4 nombres

{%%} en html significa que se va a colocar una instruccion
{% for producto in productos %}
{% endfor %}
se debera cerrar la llave para que no se repita la interacion 
{{}} para imprimir valores dentro de html 

para que la categoria nos devuelva el nombre, en models debe tener el atributo self.nombre

creamos dentro de TEMPLATES, un base.html
   {% block content %} dentro del body, es por convencion 
   {% endblock %}

   Encabezamos en index asi para pasarlo al blocke de base
   {% extends 'base.html' %}

  desde boostrap.com, vinculamos los links en el head y al final del block en base.html 
  asi ya nos va dando forma con un framework por defecto
  
  CENTRAR UN DIV:
  en base.html
  <body>
    <div class="container">
        {% block content %}

        {% endblock %}
    </div>

  error 404 UN RECURSO NO FUE ENCONTRADO

